from random import randrange
from typing import Tuple
from queue import PriorityQueue

import pygame
import pyscroll

from cannonball import CannonBall
from enemy import Enemy
from gamedata import GameData
from gamestate import GameState
from gamestate import GameStateID
from math import atan2, degrees, sqrt
from player import Player, ShipCondition


class GamePlay(GameState):
    """ The game play state is the core of the game itself.

    The role of this class is to process the game logic, update
    the players positioning and render the resultant game-world.
    The logic for deciding on victory or loss should be handled by
    this class and its update function should return GAME_OVER or
    GAME_WON when the end game state is reached.
    """

    def __init__(self, data: GameData) -> None:
        """ Creates the game world

        Use the constructor to initialise the game world in a "clean"
        state ready for the player. This includes resetting of player's
        health and the enemy positions.

        Args:
            data (GameData): The game's shared data
        """

        super().__init__(data)
        self.id = GameStateID.GAMEPLAY
        self.debug = True

        # gameplay Specific Data
        self.player = Player()
        self.group = None
        self.cannonballs = []
        self.enemies = []

        # helper functions
        self.loadMap()
        self.loadPlayer()

    def input(self, event: pygame.event) -> None:
        """ Handles the player's input

        This function handles all of the player's input in the game.
        At present, it looks to see if a specific mouse button is
        pressed and will act accordingly. For example, to launch a
        cannon you need to use the right click.

        Args:
            event (pygame.Event): The event generated by pygame
        """

        # is player holding mouse btn 1 down?
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            self.player.mouse_down = True

            start_tile = self.gamedata.gamemap.tile(self.player.position)
            end_tile = self.gamedata.gamemap.tile(self.gamedata.gamemap.inverse(event.pos))

            if start_tile != end_tile and self.gamedata.gamemap.cost(self.gamedata.gamemap.inverse(event.pos)) < 100:
                self.player.path = self.pathfinder(self.gamedata.gamemap.costs, start_tile, end_tile)

        # has player right clicked?
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:
            to_world = self.gamedata.gamemap.inverse(event.pos)
            cannonball = CannonBall(self.player.rect.center, to_world)
            self.cannonballs.append(cannonball)
            self.group.add(cannonball)

        # has player released left mouse btn?
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.player.mouse_down = False

        # toggle debug mode if d key is pressed
        elif event.type == pygame.KEYDOWN and event.key == pygame.K_d:
            self.debug = not self.debug
            return

        # if player is holding mouse btn1, update the player's position
        # if self.player.mouse_down is True:
        #     to_world = self.gamedata.gamemap.inverse(event.pos)
        #     self.player.destination = (to_world[0], to_world[1])
        #
        #     dx = self.player.destination[0] - self.player.position[0]
        #     dy = self.player.destination[1] - self.player.position[1]
        #     rad = atan2(dy, dx)
        #     self.player.rotate(degrees(rad))

    def loadMap(self) -> None:
        """ Loads the map and spawns enemies
        """
        self.group = pyscroll.PyscrollGroup(map_layer=self.gamedata.gamemap.map, default_layer=4)

        while len(self.enemies) != 3:
            enemy = Enemy()

            while enemy.rect.collidelist(self.gamedata.gamemap.islands) != -1:
                enemy.rect.x = randrange(0, self.gamedata.gamemap.map.map_rect.w - enemy.rect.width)
                enemy.rect.y = randrange(0, self.gamedata.gamemap.map.map_rect.h - enemy.rect.height)

            self.enemies.append(enemy)
            self.group.add(enemy)

    def loadPlayer(self) -> None:
        """ Loads the player and sets initial position
        """
        self.player.position = (1856, 1216)
        self.player.destination = self.player.position
        self.player.update(0)
        self.group.add(self.player)

    def update(self, dt: float) -> GameStateID:
        """ Updates the game world

        Processes the game world logic. You should handle collisions,
        actions and AI actions here. At present cannon balls are
        updated and so are player collisions with the islands, but
        consider how the ships will react to each other

        Args:
            dt (float): The time between ticks.
        """
        if self.player.score >= 2000:
            self.player.score = 0
            return GameStateID.WINNER_WINNER
        elif self.player.hp <= 0:
            self.player.hp = 10
            return GameStateID.GAME_OVER

        self.resolveCannonballs()
        # self.resolvePlayerCollisions(dt)
        self.group.update(dt)

        return GameStateID.GAMEPLAY

    def resolveCannonballs(self) -> None:
        """ Updates the active cannon balls in the world

        Checks to see if the cannon balls have reached their target
        or collided with a ship. If they hit a ship the ship's hp
        will drop by 1. This of course can be changed or tweaked.
        At present if the ship's hp is below 0, the console will
        print the "dead" message
        """
        # check to see if canonballs are finished
        for sprite in self.cannonballs:

            # check for collisions
            for enemy in self.enemies:
                if enemy.rect.colliderect(sprite.rect):
                    self.group.remove(sprite)
                    self.cannonballs.remove(sprite)
                    enemy.hp -= 1
                    print(enemy.hp)
                    self.player.score = self.player.score + 100
                    if enemy.hp == 0:
                        print("dead")

            if sprite.position == sprite.destination:
                # as lerping reduces distance over time, it might make
                # more sense to check distance between two vectors and
                # remove when close "enough"
                self.group.remove(sprite)
                self.cannonballs.remove(sprite)

    def resolvePlayerCollisions(self, dt) -> None:
        """Checks for collisions with the islands
        """
        if self.player.rect.collidelist(self.gamedata.gamemap.islands) > -1:
            print("Collision")
            self.player.hp -= 1
            self.player.move_back(dt)

    def render(self, screen: pygame.Surface) -> None:
        """ Renders the map, player and score
        """
        # center the map/screen on our Hero
        self.group.center(self.player.rect.center)

        # draw the map and all sprites
        self.group.draw(screen)

        # score
        textsurface = self.gamedata.fonts["scoreboard"].render(f'{self.player.score:06d}', True, (0, 0, 0))
        screen.blit(textsurface, (15, 25))

        # debug rendering
        self.render_debug(screen)

    def render_debug(self, screen: pygame.Surface) -> None:
        """ Renders the debug information if DEBUG is True

        Use this function to display debug information about the game world
        on the screen. At present it will print the ships current location
        in both world space and tile space. You could add extra info to help
        development such as the player's HP or it's current state.

        Args:
            screen (pygame.Surface): The window to render to
        """

        debug_font = self.gamedata.fonts["debug"]
        if self.debug:
            screen.blit(debug_font.render(f'{int(self.player.position[0]), int(self.player.position[1])}',
                        True, (0, 0, 0)), (15, 80))

            screen.blit(debug_font.render(f'{self.gamedata.gamemap.tile(self.player.position)}',
                        True, (0, 0, 0)), (15, 105))

            screen.blit(debug_font.render(f'Cost: {self.gamedata.gamemap.cost(self.player.position)}',
                        True, (0, 0, 0)), (15, 130))

    def pathfinder(self, cost_map, start, end):
        frontier = PriorityQueue()
        frontier.put((0, start))
        came_from = dict()
        cost_so_far = dict()
        came_from[start] = None
        cost_so_far[start] = 0

        while not frontier.empty():
            coordinates = frontier.get()[1]
            current = Node(coordinates[1], coordinates[0])
            current.update_neighbors(self.gamedata.gamemap.costs)

            if current.get_position() == end:
                break

            for next in current.neighbors:
                new_cost = cost_so_far[current.get_position()] + cost_map[next.get_position()[1]][next.get_position()[0]]
                if next.get_position() not in cost_so_far or new_cost < cost_so_far[next.get_position()]:
                    cost_so_far[next.get_position()] = new_cost
                    priority = new_cost + self.heuristics(end, next.get_position())
                    frontier.put((priority, next.get_position()))
                    came_from[next.get_position()] = current.get_position()

        return self.reconstruct_path(came_from, start, end)

    def heuristics (self, p1, p2):
        x1, y1 = p1
        x2, y2 = p2
        dx = abs(x1 - x2)
        dy = abs(y1 - y2)
        return sqrt(dx * dx + dy * dy)

    def reconstruct_path(self, came_from, start, end):
        current = end
        path = []
        while current != start:
            path.append(self.gamedata.gamemap.world(current))
            current = came_from[current]
        path.reverse()
        return path

class Node:
    def __init__(self, col, row) -> None:
        self.x = row
        self.y = col
        self.neighbors = []
        self.WIDTH = 60
        self.HEIGHT = 34

    def get_position(self) -> Tuple[int, int]:
        return self.x, self.y

    def update_neighbors(self, grid):
        self.neighbors = []
        if self.x < self.WIDTH - 1 and not grid[self.y][self.x + 1] > 100:  # DOWN
            self.neighbors.append(Node(self.y, self.x + 1))

        if self.x > 0 and not grid[self.y][self.x - 1] > 100:  # UP
            self.neighbors.append(Node(self.y, self.x - 1))

        if self.y < self.HEIGHT - 1 and not grid[self.y + 1][self.x] > 100:  # RIGHT
            self.neighbors.append(Node(self.y + 1, self.x))

        if self.y > 0 and not grid[self.y - 1][self.x] > 100:  # LEFT
            self.neighbors.append(Node(self.y - 1, self.x))
